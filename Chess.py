__version__ = (1, 1, 0)
# ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
# ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñë‚ñë‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
# ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë
# ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë
# ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
# ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
# ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
# ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñî‚ñà‚ñë‚ñë‚ñà‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë
# ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
# ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñÅ‚ñà‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
# ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë
# ‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà
# ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñà‚ñë‚ñà
# ‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà‚ñà‚ñà‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà‚ñë‚ñà‚ñë‚ñà‚ñë‚ñà
# ‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà‚ñë‚ñà‚ñë‚ñà‚ñë‚ñà
# ‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà‚ñë‚ñë‚ñà‚ñë‚ñë‚ñà‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà
# H:Mods Team [üíé]


# meta developer: @nullmod
# requires: python-chess
import asyncio
import random
import chess
import time

from hikkatl.tl.types import PeerUser
from .. import loader, utils
# from itertools import chain


#######–¢–∞–π–º–µ—Ä#######
class Timer:  # –µ–µ–µ –º–æ–π –ø–µ—Ä–≤—ã–π –∫–ª–∞—Å—Å
    def __init__(self, scnds):  # start
        self.timers = {"white": scnds, "black": scnds}
        self.running = {"white": False, "black": False}
        self.started = {"white": False, "black": False}
        self.last_time = time.monotonic()  # Monotonic clock, cannot go backward
        self.t = None

    async def count(self):  # func
        while True:
            await asyncio.sleep(0.1)
            now = time.monotonic()
            elapsed = now - self.last_time
            self.last_time = now
            for color in ("white", "black"):
                if self.running[color]:
                    self.timers[color] = max(
                        0, self.timers[color] - elapsed
                    )  # –Ω–∞–º –Ω–µ –Ω–∞–¥–æ –≤ –º–∏–Ω—É—Å —É—Ö–æ–¥–∏—Ç—å

    async def start(self):  ##to use
        self.last_time = time.monotonic()
        self.t = asyncio.create_task(self.count())

    async def white(self):  ##to use
        await self.turn("white")
        self.started["white"] = True
        self.started["black"] = False

    async def black(self):  ##to use
        await self.turn("black")
        self.started["white"] = False
        self.started["black"] = True

    async def turn(self, color):  # func
        now = time.monotonic()
        e = now - self.last_time
        self.last_time = now
        for clr in ("white", "black"):
            if self.running[clr]:
                self.timers[clr] = max(0, self.timers[clr] - e)
        self.running = {"white": color == "white", "black": color == "black"}

    async def white_time(self):  ##to use
        return round(self.timers["white"], 0)

    async def black_time(self):  ##to use
        return round(self.timers["black"], 0)

    async def stop(self):  ##to use#–∞ –≤–¥—Ä—É–≥ –ø–æ–Ω–∞–¥–æ–±–∏—Ç—Å—è
        if self.t:
            self.t.cancel()
        self.running = {"white": False, "black": False}
        self.timers = {"white": self.timers["white"], "black": self.timers["black"]}
        self.started = {"white": False, "black": False}

    async def clear(self):  ##to use
        if self.t:
            self.t.cancel()
        self.timers = {"white": 0, "black": 0}
        self.running = {"white": False, "black": False}
        self.started = {"white": False, "black": False}
        self.t = None

    #######–¢–∞–π–º–µ—Ä#######


@loader.tds
class Chess(loader.Module):
    """–®–∞—Ö–º–∞—Ç—ã –¥–ª—è –∏–≥—Ä—ã –≤–¥–≤–æ—ë–º."""

    strings = {"name": "Chess"}
    #####–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ#####

    async def client_ready(self):
        self.board = {}
        self.symbols = {
            "r": "‚ôú",
            "n": "‚ôû",
            "b": "‚ôù",
            "q": "ùóæ",
            "k": "‚ôö",
            "p": "‚ôü",
            "R": "‚ôñ",
            "N": "‚ôò",
            "B": "‚ôó",
            "Q": "ùó§",
            "K": "‚ôî",
            "P": "‚ôô",
        }
        # self.symbolsL = {
        #     "r": "ùóø", "n": "ùóª", "b": "ùóØ", "q": "ùóæ", "k": "ùó∏", "p": "ùóΩ",
        #     "R": "ùó•", "N": "ùó°", "B": "ùóï", "Q": "ùó§", "K": "ùóû", "P": "ùó£",
        # } –±—É–¥—Ç–æ –∫—Ç–æ-—Ç–æ –±—É–¥–µ—Ç –∑–∞ –±—É–∫–≤—ã –∏–≥—Ä–∞—Ç—å...
        self.chsn = False
        self.saymyname = (await self.client.get_me()).first_name
        self.reverse = False
        self.timeName = "‚ùå –ë–µ–∑ —á–∞—Å–æ–≤"
        self.pTime = None
        self.colorName = "—Ä–∞–Ω–¥–æ–º"
        self.you_play = None
        self.timer = False
        self.Timer = None
        self.loopState = False
        self.game = False
        self.reason = False

    async def purgeSelf(self):
        self.board = {}
        self.chsn = False
        self.reverse = False
        self.Board = None
        self.you_play = None
        self.you_n_me = []
        self.places = []
        self.message = None
        self.opp_id = None
        self.opp_name = None
        self.checkmate = False
        self.stalemate = False
        self.timeName = "‚ùå –ù–µ—Ç —á–∞—Å–æ–≤"
        self.pTime = None
        self.colorName = "—Ä–∞–Ω–¥–æ–º"
        if self.Timer:
            await self.Timer.clear()
        self.timer = False
        if self.Timer:
            self.Timer = None
        if hasattr(self, "time_message"):
            del self.time_message
        self.loopState = False
        self.game = False
        self.reason = False

    #####–ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ#####

    #####–ò–≥—Ä–∞#####
    #####–ù–∞—Å—Ç—Ä–æ–π–∫–∏#####
    async def settings(self, call, nT):
        if call.from_user.id not in self.you_n_me:
            await call.answer("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–µ –¥–ª—è –≤–∞—Å!")
            return
        if not nT:
            await call.edit(
                text=f"[‚öôÔ∏è] –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —ç—Ç–æ–π –ø–∞—Ä—Ç–∏–∏\n| - > –•–æ—Å—Ç –∏–≥—Ä–∞–µ—Ç –∑–∞ {self.colorName} —Ü–≤–µ—Ç\n| - > –í—Ä–µ–º—è: {self.timeName}",
                reply_markup=[
                    [
                        {
                            "text": f"‚è±Ô∏è –í—Ä–µ–º—è: {self.timeName}",
                            "callback": self.time,
                            "args": (nT,),
                        }
                    ],
                    [
                        {
                            "text": f"‚ôüÔ∏è –¶–≤–µ—Ç (—Ö–æ—Å—Ç–∞): {self.colorName}",
                            "callback": self.color,
                            "args": (nT,),
                        }
                    ],
                    [
                        {
                            "text": "‚§¥Ô∏è –í–µ—Ä–Ω—É—Ç—å—Å—è",
                            "callback": self.backToInvite,
                            "args": (nT,),
                        }
                    ],
                ],
            )
        else:
            await call.edit(
                text=f"[‚öôÔ∏è] –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —ç—Ç–æ–π –ø–∞—Ä—Ç–∏–∏\n| - > –•–æ—Å—Ç –∏–≥—Ä–∞–µ—Ç –∑–∞ {self.colorName} —Ü–≤–µ—Ç\n| - > –í—Ä–µ–º—è: {self.timeName}",
                reply_markup=[
                    [
                        {
                            "text": "‚ùå –í—Ä–µ–º—è: ...",
                            "action": "answer",
                            "show_alert": True,
                            "message": "–ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –≤ —á–∞—Ç–µ.\n\n–ò–∑-–∑–∞ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π –¥–ª—è –±–æ—Ç–æ–≤ –ø–∞—Ä—Ç–∏–∏ –Ω–∞ –≤—Ä–µ–º—è –º–æ–≥—É—Ç –ø—Ä–æ–≤–æ–¥–∏—Ç—å—Å—è —Ç–æ–ª—å–∫–æ –≤ –ª—Å",
                        }
                    ],
                    [
                        {
                            "text": f"‚ôüÔ∏è –¶–≤–µ—Ç (—Ö–æ—Å—Ç–∞): {self.colorName}",
                            "callback": self.color,
                            "args": (nT,),
                        }
                    ],
                    [
                        {
                            "text": "‚§¥Ô∏è –í–µ—Ä–Ω—É—Ç—å—Å—è",
                            "callback": self.backToInvite,
                            "args": (nT,),
                        }
                    ],
                ],
            )

    async def backToInvite(self, call, nT):
        if call.from_user.id not in self.you_n_me:
            await call.answer("–≠—Ç–æ –Ω–µ –¥–ª—è –≤–∞—Å!")
            return
        await call.edit(
            text=f"<a href='tg://user?id={self.opp_id}'>{self.opp_name}</a>, –≤–∞—Å –ø—Ä–∏–≥–ª–∞—Å–∏–ª–∏ —Å—ã–≥—Ä–∞—Ç—å –ø–∞—Ä—Ç–∏—é —à–∞—Ö–º–∞—Ç, –ø—Ä–∏–º–∏—Ç–µ?\n-- --\n[‚öôÔ∏è] –¢–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:\n| - > ‚Ä¢ –•–æ—Å—Ç –∏–≥—Ä–∞–µ—Ç –∑–∞ {self.colorName} —Ü–≤–µ—Ç\n| - > ‚Ä¢ –í—Ä–µ–º—è: {self.timeName}",
            reply_markup=[
                [
                    {"text": "–ü—Ä–∏–Ω–∏–º–∞—é", "callback": self.ans, "args": ("y",)},
                    {"text": "–ù–µ—Ç", "callback": self.ans, "args": ("n",)},
                ],
                [{"text": "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", "callback": self.settings, "args": (nT,)}],
                [
                    {
                        "text": "‚ùó –í–ê–ñ–ù–û",
                        "action": "answer",
                        "show_alert": True,
                        "message": "–í –∏–≥—Ä–µ —Ñ–∏–≥—É—Ä—ã –ø–æ–∫–∞–∑–∞–Ω—ã ASCII-—Å–∏–º–≤–æ–ª–∞–º–∏, –Ω–æ –≤ —Ç—ë–º–Ω–æ–π —Ç–µ–º–µ –∏—Ö —Ç—Ä—É–¥–Ω–æ —Ä–∞–∑–ª–∏—á–∏—Ç—å, –æ—Å–æ–±–µ–Ω–Ω–æ '‚ôï' –∏ '‚ôõ'.\n\n–î–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –æ–Ω–∏ –±—ã–ª–∏ –∑–∞–º–µ–Ω–µ–Ω—ã –Ω–∞ Q (–±–µ–ª) –∏ q (—á—ë—Ä–Ω).",
                    }
                ],
            ],
        )

    async def time(self, call, nT):
        if call.from_user.id not in self.you_n_me:
            await call.answer("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–µ –¥–ª—è –≤–∞—Å!")
            return
        await call.edit(
            text=f"‚Ä¢ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —ç—Ç–æ–π –ø–∞—Ä—Ç–∏–∏.\n| - > [‚è±Ô∏è] –í—Ä–µ–º—è: {self.timeName}",
            reply_markup=[
                [
                    {
                        "text": "‚ö° –ë–ª–∏—Ü",
                        "action": "answer",
                        "message": "–ë–ª–∏—Ü-–ë–ª–∏—Ü - —Å–∫–æ—Ä–æ—Å—Ç—å –±–µ–∑ –≥—Ä–∞–Ω–∏—Ü",
                    }
                ],
                [
                    {
                        "text": "3 –º–∏–Ω—É—Ç—ã",
                        "callback": self.time_handle,
                        "args": (
                            3,
                            "3 –º–∏–Ω—É—Ç—ã",
                            nT,
                        ),
                    },
                    {
                        "text": "5 –º–∏–Ω—É—Ç",
                        "callback": self.time_handle,
                        "args": (
                            5,
                            "5 –º–∏–Ω—É—Ç",
                            nT,
                        ),
                    },
                ],
                [
                    {
                        "text": "‚è±Ô∏è –†–∞–ø–∏–¥",
                        "action": "answer",
                        "message": "–û–±–¥—É–º–∞–π —Å–≤–æ—ë –ø–æ—Ä–∞–∂–µ–Ω–∏–µ",
                    }
                ],
                [
                    {
                        "text": "10 –º–∏–Ω—É—Ç",
                        "callback": self.time_handle,
                        "args": (
                            10,
                            "10 –º–∏–Ω—É—Ç",
                            nT,
                        ),
                    },
                    {
                        "text": "15 –º–∏–Ω—É—Ç",
                        "callback": self.time_handle,
                        "args": (
                            15,
                            "15 –º–∏–Ω—É—Ç",
                            nT,
                        ),
                    },
                    {
                        "text": "30 –º–∏–Ω—É—Ç",
                        "callback": self.time_handle,
                        "args": (
                            30,
                            "30 –º–∏–Ω—É—Ç",
                            nT,
                        ),
                    },
                    {
                        "text": "60 –º–∏–Ω—É—Ç",
                        "callback": self.time_handle,
                        "args": (
                            60,
                            "60 –º–∏–Ω—É—Ç",
                            nT,
                        ),
                    },
                ],
                [
                    {
                        "text": "‚ùå –ù–µ—Ç —á–∞—Å–æ–≤",
                        "callback": self.time_handle,
                        "args": (
                            None,
                            "‚ùå –ù–µ—Ç —á–∞—Å–æ–≤",
                            nT,
                        ),
                    }
                ],
                [
                    {
                        "text": "‚§¥Ô∏è –û–±—Ä–∞—Ç–Ω–æ –∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º",
                        "callback": self.settings,
                        "args": (nT,),
                    }
                ],
            ],
        )

    async def time_handle(self, call, minutes, txt, nT):
        self.timeName = txt
        self.pTime = minutes * 60
        await self.time(call, nT)

    async def color(self, call, nT):
        if call.from_user.id not in self.you_n_me:
            await call.answer("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–µ –¥–ª—è –≤–∞—Å!")
            return
        await call.edit(
            text=f"‚Ä¢ –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —ç—Ç–æ–π –ø–∞—Ä—Ç–∏–∏.\n| - > [‚ôüÔ∏è] –•–æ—Å—Ç –∏–≥—Ä–∞–µ—Ç –∑–∞: {self.colorName} —Ü–≤–µ—Ç.\n–í—ã–±–µ—Ä–∏—Ç–µ —Ü–≤–µ—Ç –µ–≥–æ —Ñ–∏–≥—É—Ä",
            reply_markup=[
                [
                    {
                        "text": "‚úÖ –ë–µ–ª—ã–µ" if self.you_play == "w" else "‚ùå –ë–µ–ª—ã–µ",
                        "callback": self.color_handle,
                        "args": (
                            "w",
                            "–±–µ–ª—ã–π",
                            nT,
                        ),
                    },
                    {
                        "text": "‚úÖ –ß—ë—Ä–Ω—ã–µ" if self.you_play == "b" else "‚ùå –ß—ë—Ä–Ω—ã–µ",
                        "callback": self.color_handle,
                        "args": (
                            "b",
                            "—á—ë—Ä–Ω—ã–π",
                            nT,
                        ),
                    },
                ],
                [
                    {
                        "text": "üé≤ –†–∞–Ω–¥–æ–º" if not self.you_play else "‚ùå –†–∞–Ω–¥–æ–º",
                        "callback": self.color_handle,
                        "args": (None, "—Ä–∞–Ω–¥–æ–º", nT),
                    }
                ],
                [
                    {
                        "text": "‚§¥Ô∏è –û–±—Ä–∞—Ç–Ω–æ –∫ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞–º",
                        "callback": self.settings,
                        "args": (nT,),
                    }
                ],
            ],
        )

    async def color_handle(self, call, color, txt, nT):
        if call.from_user.id not in self.you_n_me:
            await call.answer("–ù–∞—Å—Ç—Ä–æ–π–∫–∏ –Ω–µ –¥–ª—è –≤–∞—Å!")
            return
        self.colorName = txt
        self.you_play = color
        await self.color(call, nT)
        #####–ù–∞—Å—Ç—Ä–æ–π–∫–∏#####

    @loader.command()
    async def chess(self, message):
        """[reply/username/id] –ø—Ä–µ–¥–ª–æ–∂–∏—Ç—å —á–µ–ª–æ–≤–µ–∫—É —Å—ã–≥—Ä–∞—Ç—å –ø–∞—Ä—Ç–∏—é –≤ —á–∞—Ç–µ"""
        if self.board:
            await message.edit(
                "<emoji document_id=5370724846936267183>ü§î</emoji> –ü–∞—Ä—Ç–∏—è —É–∂–µ –≥–¥–µ-—Ç–æ –∑–∞–ø—É—â–µ–Ω–∞. –ó–∞–≤–µ—Ä—à–∏—Ç–µ –∏–ª–∏ —Å–±—Ä–æ—Å—å—Ç–µ –µ—ë —Å <code>purgegame</code>"
            )
            return
        await self.purgeSelf()  # –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –º–Ω–µ —Ç—É—Ç –Ω–µ –æ–±—Ö–æ–¥–∏—Ç–µ –∞–≥–∞
        self.message = message
        self.message_chat = message.chat_id
        noTimer = False
        if not isinstance(message.peer_id, PeerUser):
            noTimer = True
        if message.is_reply:
            r = await message.get_reply_message()
            opponent = r.sender
            self.opp_id = opponent.id
            self.opp_name = opponent.first_name
        else:
            args = utils.get_args(message)
            if len(args) == 0:
                await message.edit(
                    "<emoji document_id=5370724846936267183>ü§î</emoji> –í—ã –Ω–µ —É–∫–∞–∑–∞–ª–∏ —Å –∫–µ–º –∏–≥—Ä–∞—Ç—å"
                )
                return
            opponent = args[0]
            try:
                if opponent.isdigit():
                    self.opp_id = int(opponent)
                    opponent = await self.client.get_entity(self.opp_id)
                    self.opp_name = opponent.first_name
                else:
                    opponent = await self.client.get_entity(opponent)
                    self.opp_name = opponent.first_name
                    self.opp_id = opponent.id
            except:  # noqa: E722
                await message.edit("‚ùå –Ø –Ω–µ –Ω–∞—Ö–æ–∂—É —Ç–∞–∫–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è")
                return
        if self.opp_id == self.message.sender_id:
            await message.edit(
                "<emoji document_id=5384398004172102616>üòà</emoji> –û–¥–∏–Ω–æ—á–Ω—ã–µ —à–∞—Ö–º–∞—Ç—ã? –ü—Ä–æ—Å—Ç–∏—Ç–µ, –Ω–µ—Ç."
            )
            return
        self.you_n_me = [self.opp_id, self.message.sender_id]
        await self.inline.form(
            message=message,
            text=f"<a href='tg://user?id={self.opp_id}'>{self.opp_name}</a>, –≤–∞—Å –ø—Ä–∏–≥–ª–∞—Å–∏–ª–∏ —Å—ã–≥—Ä–∞—Ç—å –ø–∞—Ä—Ç–∏—é —à–∞—Ö–º–∞—Ç, –ø—Ä–∏–º–∏—Ç–µ?\n-- --\n[‚öôÔ∏è] –¢–µ–∫—É—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏:\n| - > ‚Ä¢ –•–æ—Å—Ç –∏–≥—Ä–∞–µ—Ç –∑–∞ {self.colorName} —Ü–≤–µ—Ç\n| - > ‚Ä¢ –í—Ä–µ–º—è: {self.timeName}",
            reply_markup=[
                [
                    {"text": "–ü—Ä–∏–Ω–∏–º–∞—é", "callback": self.ans, "args": ("y",)},
                    {"text": "–ù–µ—Ç", "callback": self.ans, "args": ("n",)},
                ],
                [
                    {
                        "text": "‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏",
                        "callback": self.settings,
                        "args": (noTimer,),
                    }
                ],
                [
                    {
                        "text": "‚ùó –í–ê–ñ–ù–û",
                        "action": "answer",
                        "show_alert": True,
                        "message": "–í –∏–≥—Ä–µ —Ñ–∏–≥—É—Ä—ã –ø–æ–∫–∞–∑–∞–Ω—ã ASCII-—Å–∏–º–≤–æ–ª–∞–º–∏, –Ω–æ –≤ —Ç—ë–º–Ω–æ–π —Ç–µ–º–µ –∏—Ö —Ç—Ä—É–¥–Ω–æ —Ä–∞–∑–ª–∏—á–∏—Ç—å, –æ—Å–æ–±–µ–Ω–Ω–æ '‚ôï' –∏ '‚ôõ'.\n\n–î–ª—è —É–¥–æ–±—Å—Ç–≤–∞ –æ–Ω–∏ –±—ã–ª–∏ –∑–∞–º–µ–Ω–µ–Ω—ã –Ω–∞ Q (–±–µ–ª) –∏ q (—á—ë—Ä–Ω).",
                    }
                ],
            ],
            disable_security=True,
            on_unload=self.outdated(),
        )

    @loader.command()
    async def purgeGame(self, message):
        """–ì—Ä—É–±–æ –∑–∞–≤–µ—Ä—à–∏—Ç—å –ø–∞—Ä—Ç–∏—é, –æ—á–∏—Å—Ç–∏–≤ –í–°–ï —Å–≤—è–∑–∞–Ω–Ω—ã–µ —Å –Ω–µ–π –¥–∞–Ω–Ω—ã–µ"""
        await self.purgeSelf()
        await message.edit("–î–∞–Ω–Ω—ã–µ –æ—á–∏—â–µ–Ω—ã")

    async def ans(self, call, data):
        if call.from_user.id == self.message.sender_id:
            await call.answer("–î–∞–π —á–µ–ª–æ–≤–µ–∫—É –æ—Ç–≤–µ—Ç–∏—Ç—å!")
            return
        if call.from_user.id not in self.you_n_me:
            await call.answer("–ù–µ —Ç–µ–±–µ –ø—Ä–µ–¥–ª–∞–≥–∞—é—Ç –∂")
            return
        if data == "y":
            self.Board = chess.Board()
            if not self.you_play:
                await call.edit(text="–í—ã–±–∏—Ä–∞—é —Å—Ç–æ—Ä–æ–Ω—ã...")
                await asyncio.sleep(0.5)
                self.you_play = self.ranColor()
            text = await self.sttxt()
            await call.edit(text="–ó–∞–≥—Ä—É–∑–∫–∞ –¥–æ—Å–∫–∏...")
            await asyncio.sleep(0.5)
            if self.pTime:
                await call.edit(text="–°—Ç–∞–≤–ª—é —Ç–∞–π–º–µ—Ä—ã...")
                self.Timer = Timer(self.pTime)
                self.timer = True
                self.brd = call
                await asyncio.sleep(0.5)
            else:
                self.game = True
            await call.edit(
                text="[!] –î–ª—è –ª—É—á—à–µ–≥–æ —Ä–∞–∑–ª–∏—á–∏—è —Ñ–∏–≥—É—Ä –≤–∫–ª—é—á–∏—Ç–µ —Å–≤–µ—Ç–ª—É—é —Ç–µ–º—É!"
            )
            await asyncio.sleep(2.5)
            await self.LoadBoard(text, call)
        else:
            await call.edit(text="–û—Ç–∫–ª–æ–Ω–µ–Ω–æ.")

    #####–ò–≥—Ä–∞#####

    #####–¢–∞–π–º–µ—Ä#####
    async def start_timer(self, call):
        if call.from_user.id not in self.you_n_me:
            await call.answer("–ü–∞—Ä—Ç–∏—è –Ω–µ –≤–∞—à–∞!")
            return
        await self.Timer.start()
        self.time_message = call
        self.TimerLoop.start()
        self.loopState = True
        self.game = True

    @loader.loop(interval=1)
    async def TimerLoop(self):
        if self.loopState:
            await self.time_message.edit(
                text=f"‚ôî –ë–µ–ª—ã–µ: {int(await self.Timer.white_time())}\n‚ôö –ß—ë—Ä–Ω—ã–µ: {int(await self.Timer.black_time())}"
            )
            t = await self.sttxt()
            if not self.timer and self.Timer:
                await self.LoadBoard(t, self.brd)

    #####–¢–∞–π–º–µ—Ä#####

    #####–î–æ—Å–∫–∞#####

    async def LoadBoard(self, text, call):
        if self.timer:
            if not hasattr(self, "time_message"):
                m = await self.client.send_message(
                    self.message_chat, "–ù–∞—Å—Ç—Ä–æ–π–∫–∞ —Ç–∞–π–º–µ—Ä–∞..."
                )
                await self.inline.form(
                    message=m,
                    text=f"‚ôî –ë–µ–ª—ã–µ: {await self.Timer.white_time()}\n‚ôö –ß—ë—Ä–Ω—ã–µ: {await self.Timer.black_time()}\n‚è≥ –ù–∞—á–Ω—ë–º?",
                    reply_markup=[
                        {"text": "–ù–∞—á–∞—Ç—å –ø–∞—Ä—Ç–∏—é", "callback": self.start_timer}
                    ],
                    disable_security=True,
                )

        elif self.Timer:
            self.loopState = False
            await self.time_message.edit(
                text=f"‚ôî –ë–µ–ª—ã–µ: {int(await self.Timer.white_time())}\n‚ôö –ß—ë—Ä–Ω—ã–µ: {int(await self.Timer.black_time())}\n‚ùå –û—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –ø–æ –ø—Ä–∏—á–∏–Ω–µ: {self.reason}"
            )
        for row in range(1, 9):
            rows = []
            for col in "ABCDEFGH":
                coord = f"{col}{row}"
                piece = self.Board.piece_at(chess.parse_square(coord.lower()))
                self.board[coord] = self.symbols[piece.symbol()] if piece else " "

        btns = []
        for row in range(1, 9):
            rows = []
            for col in "ABCDEFGH":
                coord = f"{col}{row}"
                rows.append(
                    {
                        "text": f"{self.board[f'{col}{row}']}",
                        "callback": self.clicks_handle,
                        "args": (coord,),
                    }
                )
            btns.append(rows)

        await call.edit(text=text, reply_markup=btns[::-1], disable_security=True)

    async def UpdBoard(self, call):
        # log = []
        # log.append(f"plcs: {self.places}")
        for row in range(1, 9):
            rows = []
            for col in "ABCDEFGH":
                coord = f"{col}{row}"
                for place in self.places:
                    # log.append(f"p: {coord}")
                    if place[2:4] == coord.lower():
                        # log.append("yes")
                        if len(place) == 5:
                            self.board[coord] = (
                                "√ó‚Üª"
                                if (
                                    move := next(
                                        (
                                            chess.Move.from_uci(p)
                                            for p in self.places
                                            if p[2:4] == coord.lower()
                                        ),
                                        None,
                                    )
                                )
                                and self.Board.is_capture(move)
                                else "‚Üª"
                            )
                        else:
                            self.board[coord] = (
                                "√ó"
                                if (
                                    move := next(
                                        (
                                            chess.Move.from_uci(p)
                                            for p in self.places
                                            if p[2:4] == coord.lower()
                                        ),
                                        None,
                                    )
                                )
                                and self.Board.is_capture(move)
                                else "‚óè"
                            )
                        break

                    else:
                        # log.append(f"nothing")
                        piece = self.Board.piece_at(chess.parse_square(coord.lower()))
                        self.board[coord] = (
                            self.symbols[piece.symbol()] if piece else " "
                        )
        # await self.client.send_message("me",f"{log}")

        text = await self.sttxt()
        btns = []
        for row in range(1, 9):
            rows = []
            for col in "ABCDEFGH":
                coord = f"{col}{row}"
                rows.append(
                    {
                        "text": f"{self.board[f'{col}{row}']}",
                        "callback": self.clicks_handle,
                        "args": (coord,),
                    }
                )
            btns.append(rows)

        await call.edit(text=text, reply_markup=btns[::-1], disable_security=True)

    #####–î–æ—Å–∫–∞#####

    #####–§—É–Ω–∫–∏#####(–¥–ª—è –±—É–¥—É—é—â–µ–π –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏ –∫–æ–¥–∞)
    async def drawBoard(self):
        for row in range(1, 9):
            rows = []  # noqa: F841
            for col in "ABCDEFGH":
                coord = f"{col}{row}"
                for place in self.places:
                    if place[2:4] == coord.lower():
                        if len(place) == 5:
                            self.board[coord] = (
                                "√ó‚Üª"
                                if (
                                    move := next(
                                        (
                                            chess.Move.from_uci(p)
                                            for p in self.places
                                            if p[2:4] == coord.lower()
                                        ),
                                        None,
                                    )
                                )
                                and self.Board.is_capture(move)
                                else "‚Üª"
                            )
                        else:
                            self.board[coord] = (
                                "√ó"
                                if (
                                    move := next(
                                        (
                                            chess.Move.from_uci(p)
                                            for p in self.places
                                            if p[2:4] == coord.lower()
                                        ),
                                        None,
                                    )
                                )
                                and self.Board.is_capture(move)
                                else "‚óè"
                            )
                        break

                    else:
                        piece = self.Board.piece_at(chess.parse_square(coord.lower()))
                        self.board[coord] = (
                            self.symbols[piece.symbol()] if piece else " "
                        )
        return

    async def moveTo(s, ca, c):
        s.Board.push(chess.Move.from_uci(c))
        s.reverse = not s.reverse
        s.chsn = False
        t = await s.sttxt()
        await s.LoadBoard(t, ca)

    #####–§—É–Ω–∫–∏#####

    #####–•–æ–¥—ã#####

    async def choose_figure(self, p, c):
        text = await self.sttxt()
        btns = []
        await self.drawBoard()
        for row in range(1, 9):
            rows = []
            for col in "ABCDEFGH":
                coord = f"{col}{row}"  # noqa: F841
                rows.append(
                    {
                        "text": f"{self.board[f'{col}{row}']}",
                        "action": "answer",
                        "message": "–í—ã –Ω–µ –º–æ–∂–µ—Ç–µ —Ö–æ–¥–∏—Ç—å, –ø–æ–∫–∞ –Ω–µ –±—É–¥–µ—Ç —Å–¥–µ–ª–∞–Ω –≤—ã–±–æ—Ä",
                        "show_alert": True,
                    }
                )
            btns.append(rows)
        p = p[0:4]
        btns = btns[::-1]
        btns.append(
            [
                {
                    "text": "‚¨áÔ∏è‚Üª‚¨áÔ∏è",
                    "action": "answer",
                    "message": "–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∏–≥—É—Ä—É –¥–ª—è –ø—Ä–µ–≤—Ä–∞—â–µ–Ω–∏—è",
                }
            ]
        )
        btns.append(
            [
                {"text": "‚ôõ", "callback": self.are_u, "args": (p + "q",)},
                {"text": "‚ôú", "callback": self.are_u, "args": (p + "r",)},
                {"text": "‚ôû", "callback": self.are_u, "args": (p + "n",)},
                {"text": "‚ôù", "callback": self.are_u, "args": (p + "b",)},
            ]
        )
        await c.edit(text=text, reply_markup=btns, disable_security=True)

    async def are_u(s, c, p):  # SCP FOUNDATION
        current_player = (
            s.message.sender_id if (s.you_play == "w") ^ s.reverse else s.opp_id
        )
        if c.from_user.id != current_player:
            await c.answer("–í—ã–±–æ—Ä –∑–∞ –≤–∞—à–∏–º –æ–ø–ø–æ–Ω–µ–Ω—Ç–æ–º")
            return
        await s.moveTo(c, p)

    async def clicks_handle(self, call, coord):
        if self.checkmate or self.stalemate or self.fifty or self.reason:
            await call.answer("–ü–∞—Ä—Ç–∏—è –æ–∫–æ–Ω—á–µ–Ω–∞. –î–æ—Å—Ç—É–ø–Ω—ã—Ö —Ö–æ–¥–æ–≤ –Ω–µ—Ç.")
            await self.purgeSelf()
            return
        if call.from_user.id not in self.you_n_me:
            await call.answer("–ü–∞—Ä—Ç–∏—è –Ω–µ –≤–∞—à–∞ –∏–ª–∏ —É–∂–µ —Å–±—Ä–æ—à–µ–Ω–∞")
            return
        if not self.game:
            await call.answer("–í—ã –Ω–µ –∑–∞–ø—É—Å—Ç–∏–ª–∏ —Ç–∞–π–º–µ—Ä")
            return
        current_player = (
            self.message.sender_id
            if (self.you_play == "w") ^ self.reverse
            else self.opp_id
        )
        if call.from_user.id != current_player:
            await call.answer("–ö—ã—à –æ—Ç –º–æ–∏—Ö —Ñ–∏–≥—É—Ä")
            return

        if self.chsn is False:
            await self.checkMove(call, coord)
        else:
            for place in self.places:
                if place[2:4] == coord.lower():
                    if len(place) == 5:
                        await self.choose_figure(place, call)  ######
                        return
                    matching_place = place
                    break
                else:
                    matching_place = None
            if matching_place:
                self.Board.push(chess.Move.from_uci(matching_place))
                self.reverse = not self.reverse
                self.chsn = False
            else:
                prev_place = next(
                    (place for place in self.places if place[0:2] == coord.lower()),
                    None,
                )
                text = await self.sttxt()
                if prev_place:
                    self.chsn = False
                    self.places = []
                    await self.LoadBoard(text, call)
                    return
                if not await self.checkMove(call, coord):
                    self.chsn = False
                    self.places = []
                    await self.LoadBoard(text, call)
                    return
                else:
                    return
            text = await self.sttxt()
            await self.LoadBoard(text, call)

    async def checkMove(self, call, coord):
        if self.Board.piece_at(chess.parse_square(coord.lower())):
            square = chess.parse_square(coord.lower())
            moves = [
                move for move in self.Board.legal_moves if move.from_square == square
            ]
            self.places = [p for p in [move.uci() for move in moves]]
            if not self.places:
                await call.answer("–î–ª—è —ç—Ç–æ–π —Ñ–∏–≥—É—Ä—ã –Ω–µ—Ç —Ö–æ–¥–æ–≤!")
                return None
        else:
            await call.answer("–¢—É—Ç –Ω–µ—Ç —Ñ–∏–≥—É—Ä—ã")
            self.places = []
            self.chsn = False
            return None

        self.chsn = True
        await call.answer("–î–æ—Å—Ç—É–ø–Ω—ã–µ —Ö–æ–¥—ã:")
        await self.UpdBoard(call)
        return True

    async def sttxt(self):
        check = False
        self.checkmate = False
        self.stalemate = False
        self.fifty = False
        if self.Board.is_checkmate():
            self.checkmate = True
            self.timer = False
            self.reason = "–®–∞—Ö –∏ –º–∞—Ç"
        elif self.Board.is_check():
            check = True
        elif self.Board.is_stalemate():
            self.stalemate = True
            self.timer = False
            self.reason = "–ü–∞—Ç"
        elif self.Board.can_claim_fifty_moves():
            self.Board.outcome()
            self.fifty = True
            self.timer = False
            self.reason = "50 —Ö–æ–¥–æ–≤"
        elif self.timer:
            if int(await self.Timer.black_time()) == 0:
                self.timer = False
                self.reason = "–ò—Å—Ç–µ–∫–ª–æ –≤—Ä–µ–º—è —É —á—ë—Ä–Ω—ã—Ö"
            elif int(await self.Timer.white_time()) == 0:
                self.timer = False
                self.reason = "–ò—Å—Ç–µ–∫–ª–æ –≤—Ä–µ–º—è —É –±–µ–ª—ã—Ö"

        if not self.checkmate and not check and not self.stalemate and not self.reason:
            if self.reverse:
                if self.Timer:
                    await self.Timer.black()
                if self.you_play == "w":
                    return f"[..] ‚ôî –ë–µ–ª—ã–µ - {self.saymyname}\n[üëâ] ‚ôö –ß—ë—Ä–Ω—ã–µ - {self.opp_name} (–≤–∞—à —Ö–æ–¥)"
                else:
                    return f"[..] ‚ôî –ë–µ–ª—ã–µ - {self.opp_name}\n[üëâ] ‚ôö –ß—ë—Ä–Ω—ã–µ - {self.saymyname} (–≤–∞—à —Ö–æ–¥)"
            else:
                if self.Timer:
                    await self.Timer.white()
                if self.you_play == "w":
                    return f"[üëâ] ‚ôî –ë–µ–ª—ã–µ - {self.saymyname} (–≤–∞—à —Ö–æ–¥)\n[..] ‚ôö –ß—ë—Ä–Ω—ã–µ - {self.opp_name}"
                else:
                    return f"[üëâ] ‚ôî –ë–µ–ª—ã–µ - {self.opp_name} (–≤–∞—à —Ö–æ–¥)\n[..] ‚ôö –ß—ë—Ä–Ω—ã–µ - {self.saymyname}"
        elif self.checkmate:
            if self.reverse:
                if self.you_play == "w":
                    return f"‚ôî –ë–µ–ª—ã–µ - {self.saymyname}\n‚ôö –ß—ë—Ä–Ω—ã–µ - {self.opp_name}\n\nüéâ –®–∞—Ö –∏ –º–∞—Ç! –ü–æ–±–µ–¥–∏–ª(–∞) {self.saymyname}"
                else:
                    return f"‚ôî –ë–µ–ª—ã–µ - {self.opp_name}\n‚ôö –ß—ë—Ä–Ω—ã–µ - {self.saymyname}\n\nüéâ –®–∞—Ö –∏ –º–∞—Ç! –ü–æ–±–µ–¥–∏–ª(–∞) {self.opp_name}"
            else:
                if self.you_play == "w":
                    return f"‚ôî –ë–µ–ª—ã–µ - {self.saymyname} \n‚ôö –ß—ë—Ä–Ω—ã–µ - {self.opp_name}\n\nüéâ –®–∞—Ö –∏ –º–∞—Ç! –ü–æ–±–µ–¥–∏–ª(–∞) {self.opp_name}"
                else:
                    return f"‚ôî –ë–µ–ª—ã–µ - {self.opp_name} \n‚ôö –ß—ë—Ä–Ω—ã–µ - {self.saymyname}\n\nüéâ –®–∞—Ö –∏ –º–∞—Ç! –ü–æ–±–µ–¥–∏–ª(–∞) {self.saymyname}"
        elif check:
            if self.reverse:
                if self.Timer:
                    await self.Timer.black()
                if self.you_play == "w":
                    return f"[..] ‚ôî –ë–µ–ª—ã–µ - {self.saymyname}\n[üëâ] ‚ôö –ß—ë—Ä–Ω—ã–µ - {self.opp_name}\n\n‚ùó –®–∞—Ö!"
                else:
                    return f"[..] ‚ôî –ë–µ–ª—ã–µ - {self.opp_name}\n[üëâ] ‚ôö –ß—ë—Ä–Ω—ã–µ - {self.saymyname}\n\n‚ùó –®–∞—Ö!"
            else:
                if self.Timer:
                    await self.Timer.white()
                if self.you_play == "w":
                    return f"[üëâ] ‚ôî –ë–µ–ª—ã–µ - {self.saymyname} \n[..] ‚ôö –ß—ë—Ä–Ω—ã–µ - {self.opp_name}\n\n‚ùó –®–∞—Ö!"
                else:
                    return f"[üëâ] ‚ôî –ë–µ–ª—ã–µ - {self.opp_name} \n[..] ‚ôö –ß—ë—Ä–Ω—ã–µ - {self.saymyname}\n\n‚ùó –®–∞—Ö!"
        elif self.stalemate:
            if self.reverse:
                if self.you_play == "w":
                    return f"‚ôî –ë–µ–ª—ã–µ - {self.saymyname}\n‚ôö –ß—ë—Ä–Ω—ã–µ - {self.opp_name}\n\nü§ù –ü–∞—Ç. –ù–∏—á—å—è"
                else:
                    return f"‚ôî –ë–µ–ª—ã–µ - {self.opp_name}\n‚ôö –ß—ë—Ä–Ω—ã–µ - {self.saymyname}\n\nü§ù –ü–∞—Ç. –ù–∏—á—å—è"
            else:
                if self.you_play == "w":
                    return f"‚ôî –ë–µ–ª—ã–µ - {self.saymyname} \n‚ôö –ß—ë—Ä–Ω—ã–µ - {self.opp_name}\n\nü§ù –ü–∞—Ç. –ù–∏—á—å—è"
                else:
                    return f"‚ôî –ë–µ–ª—ã–µ - {self.opp_name} \n‚ôö –ß—ë—Ä–Ω—ã–µ - {self.saymyname}\n\nü§ù –ü–∞—Ç. –ù–∏—á—å—è"
        elif self.fifty:
            if self.reverse:
                if self.you_play == "w":
                    return f"‚ôî –ë–µ–ª—ã–µ - {self.saymyname}\n‚ôö –ß—ë—Ä–Ω—ã–µ - {self.opp_name}\n\nü§ù –ü—Ä–∞–≤–∏–ª–æ 50 —Ö–æ–¥–æ–≤. –ù–∏—á—å—è"
                else:
                    return f"‚ôî –ë–µ–ª—ã–µ - {self.opp_name}\n‚ôö –ß—ë—Ä–Ω—ã–µ - {self.saymyname}\n\nü§ù –ü—Ä–∞–≤–∏–ª–æ 50 —Ö–æ–¥–æ–≤. –ù–∏—á—å—è"
            else:
                if self.you_play == "w":
                    return f"‚ôî –ë–µ–ª—ã–µ - {self.saymyname} \n‚ôö –ß—ë—Ä–Ω—ã–µ - {self.opp_name}\n\nü§ù –ü—Ä–∞–≤–∏–ª–æ 50 —Ö–æ–¥–æ–≤. –ù–∏—á—å—è"
                else:
                    return f"‚ôî –ë–µ–ª—ã–µ - {self.opp_name} \n‚ôö –ß—ë—Ä–Ω—ã–µ - {self.saymyname}\n\nü§ù –ü—Ä–∞–≤–∏–ª–æ 50 —Ö–æ–¥–æ–≤. –ù–∏—á—å—è"
        elif self.Timer and self.reason:
            if int(await self.Timer.white_time()) == 0:
                return f"‚ôî –ë–µ–ª—ã–µ - {self.saymyname}\n‚ôö –ß—ë—Ä–Ω—ã–µ - {self.opp_name}\n\n‚ùó‚è±Ô∏è –ò—Å—Ç–µ–∫–ª–æ –≤—Ä–µ–º—è: {self.saymyname}. üéâ –ü–æ–±–µ–¥–∏–ª(–∞) {self.opp_name}"
            else:
                return f"‚ôî –ë–µ–ª—ã–µ - {self.opp_name}\n‚ôö –ß—ë—Ä–Ω—ã–µ - {self.saymyname}\n\n‚ùó‚è±Ô∏è –ò—Å—Ç–µ–∫–ª–æ –≤—Ä–µ–º—è: {self.opp_name}. üéâ –ü–æ–±–µ–¥–∏–ª(–∞) {self.saymyname}"

    #####–•–æ–¥—ã#####

    ##########
    async def outdated(self):
        await self.purgeSelf()
        return

    def ranColor(self):
        return "w" if random.randint(1, 2) == 1 else "b"

    #########
